<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wild Lands: RPG Engine</title>
    <style>
        :root {
            --primary: #ffd700;
            --danger: #ff4444;
            --mana: #4488ff;
            --stamina: #44ff44;
            --bg-dark: rgba(0, 0, 0, 0.7);
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #000;
            user-select: none;
            cursor: none; /* Hide default cursor */
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Top HUD */
        #hud-top {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .panel {
            background: var(--bg-dark);
            padding: 15px;
            border-radius: 8px;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        /* Stat Bars */
        .bar-group { margin-bottom: 8px; }
        .bar-label { font-size: 0.7rem; text-transform: uppercase; color: #aaa; margin-bottom: 2px; display: flex; justify-content: space-between; }
        .bar-container {
            width: 250px; height: 12px;
            background: #222;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }
        .bar-fill { height: 100%; transition: width 0.1s linear; }
        .bar-health { background: linear-gradient(90deg, #aa0000, var(--danger)); }
        .bar-mana { background: linear-gradient(90deg, #0033aa, var(--mana)); }
        .bar-stamina { background: linear-gradient(90deg, #005500, var(--stamina)); }

        /* Minimap */
        #minimap-container {
            width: 150px; height: 150px;
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.3);
            overflow: hidden;
            background: #000;
            position: relative;
        }
        #minimap-canvas { width: 100%; height: 100%; object-fit: cover; opacity: 0.8; }
        #minimap-player {
            position: absolute; top: 50%; left: 50%;
            width: 8px; height: 8px;
            background: var(--primary);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px var(--primary);
        }

        /* Clock & Info */
        #world-info { text-align: right; }
        #clock-time { font-size: 2rem; font-weight: bold; font-family: monospace; }
        #day-count { color: var(--primary); font-size: 0.9rem; }

        /* Bottom HUD */
        #hud-bottom {
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 20px;
        }

        /* Hotbar */
        #hotbar {
            display: flex;
            gap: 5px;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 10px;
        }
        .slot {
            width: 50px; height: 50px;
            background: rgba(50,50,50,0.5);
            border: 2px solid #555;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            position: relative;
            transition: all 0.2s;
        }
        .slot.active { border-color: var(--primary); transform: translateY(-5px); box-shadow: 0 0 10px var(--primary); background: rgba(100,100,100,0.6); }
        .slot-key { position: absolute; top: 2px; left: 4px; font-size: 0.7rem; color: #aaa; }
        .slot-count { position: absolute; bottom: 2px; right: 4px; font-size: 0.8rem; color: white; font-weight: bold; }

        /* Crosshair */
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: flex; justify-content: center; align-items: center;
        }
        #crosshair-dot { width: 4px; height: 4px; background: white; border-radius: 50%; box-shadow: 0 0 4px black; }
        #crosshair-circle { 
            position: absolute; width: 20px; height: 20px; 
            border: 1px solid rgba(255,255,255,0.5); 
            border-radius: 50%; 
            transition: width 0.1s, height 0.1s; 
        }

        /* Messages */
        #message-log {
            position: absolute;
            left: 20px; bottom: 120px;
            width: 300px;
            display: flex;
            flex-direction: column-reverse; /* New messages at bottom */
            gap: 5px;
            pointer-events: none;
        }
        .log-entry {
            background: rgba(0,0,0,0.4);
            color: #ddd;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
            animation: fadeOut 5s forwards;
            border-left: 3px solid transparent;
        }
        .log-gain { border-left-color: var(--stamina); color: #cfc; }
        .log-warn { border-left-color: var(--danger); color: #fcc; }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translateX(-10px); }
            10% { opacity: 1; transform: translateX(0); }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Overlay Screens */
        #blocker {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 15, 20, 0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 20; color: white;
        }
        
        #game-over { display: none; background: black; z-index: 30; }

        h1 { font-size: 4rem; color: var(--primary); text-shadow: 0 0 20px orange; margin: 0; letter-spacing: 5px; }
        .btn {
            background: linear-gradient(45deg, #ffd700, #ffaa00);
            border: none; padding: 15px 40px;
            font-size: 1.2rem; font-weight: bold;
            color: black; border-radius: 30px;
            cursor: pointer; margin-top: 20px;
            transition: transform 0.2s;
            pointer-events: auto;
        }
        .btn:hover { transform: scale(1.05); filter: brightness(1.2); }

        .keys-grid {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;
            background: rgba(255,255,255,0.05); padding: 30px; border-radius: 10px; margin: 20px 0;
        }
        .key-row { display: flex; justify-content: space-between; width: 100%; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; }
        kbd { background: #eee; color: #333; padding: 2px 6px; border-radius: 4px; font-weight: bold; font-family: monospace; }

        #build-preview-info {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            color: var(--primary); font-weight: bold; background: rgba(0,0,0,0.8); padding: 5px 15px; border-radius: 20px;
            display: none;
        }

        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #050505; color: var(--primary);
            display: flex; justify-content: center; align-items: center;
            font-family: monospace; font-size: 1.5rem; z-index: 100;
        }
    </style>
    <!-- THREE.JS IMPORT MAP -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="loader">INITIALIZING ENGINE...</div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div id="hud-top">
            <div class="panel">
                <div class="bar-group">
                    <div class="bar-label"><span>Health</span> <span id="val-hp">100/100</span></div>
                    <div class="bar-container"><div class="bar-fill bar-health" id="bar-hp"></div></div>
                </div>
                <div class="bar-group">
                    <div class="bar-label"><span>Mana</span> <span id="val-mp">50/50</span></div>
                    <div class="bar-container"><div class="bar-fill bar-mana" id="bar-mp"></div></div>
                </div>
                <div class="bar-group">
                    <div class="bar-label"><span>Stamina</span> <span id="val-st">100/100</span></div>
                    <div class="bar-container"><div class="bar-fill bar-stamina" id="bar-st"></div></div>
                </div>
            </div>

            <div class="panel" id="world-info">
                <div id="clock-time">12:00</div>
                <div id="day-count">Day 1</div>
                <div id="weather-status" style="color:#aaa; font-size: 0.8rem; margin-top:5px;">Clear Sky</div>
                <div style="margin-top: 10px;">
                    <div id="minimap-container">
                        <canvas id="minimap-canvas" width="150" height="150"></canvas>
                        <div id="minimap-player"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="message-log"></div>

        <div id="build-preview-info">BUILD MODE: [L-CLICK] Place | [R-CLICK] Remove</div>

        <div id="hud-bottom">
            <div id="hotbar">
                <div class="slot active" data-id="1"><span class="slot-key">1</span>‚öîÔ∏è</div>
                <div class="slot" data-id="2"><span class="slot-key">2</span>üîÆ</div>
                <div class="slot" data-id="3"><span class="slot-key">3</span>ü™µ<span class="slot-count" id="count-wood">0</span></div>
                <div class="slot" data-id="4"><span class="slot-key">4</span>ü™®<span class="slot-count" id="count-stone">0</span></div>
            </div>
        </div>

        <div id="crosshair">
            <div id="crosshair-dot"></div>
            <div id="crosshair-circle"></div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="blocker">
        <h1>WILD LANDS</h1>
        <p style="color: #888; letter-spacing: 2px; margin-bottom: 30px;">RPG SURVIVAL ENGINE</p>
        
        <div class="keys-grid">
            <div class="key-row"><span>Movement</span> <span><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd></span></div>
            <div class="key-row"><span>Jump / Sprint</span> <span><kbd>SPACE</kbd> / <kbd>SHIFT</kbd></span></div>
            <div class="key-row"><span>Interact / Attack</span> <span><kbd>L-CLICK</kbd></span></div>
            <div class="key-row"><span>Magic / Alt</span> <span><kbd>R-CLICK</kbd></span></div>
            <div class="key-row"><span>Toggle Build Mode</span> <span><kbd>B</kbd></span></div>
            <div class="key-row"><span>Select Tool</span> <span><kbd>1</kbd>-<kbd>4</kbd></span></div>
        </div>

        <button class="btn" id="start-btn">AWAKEN</button>
    </div>

    <!-- Game Over -->
    <div id="game-over" class="overlay">
        <h1 style="color: #ff3333;">FATALITY</h1>
        <p>Your journey ends here.</p>
        <button class="btn" onclick="location.reload()">RESURRECT</button>
    </div>

    <!-- ENGINE CODE -->
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { SimplexNoise } from 'three/addons/math/SimplexNoise.js'; // Note: Not standard in additives, will use math function fallback

        // ==========================================
        // CONFIGURATION & CONSTANTS
        // ==========================================
        const CONFIG = {
            WORLD_SIZE: 2000,
            CHUNK_RES: 64,
            GRAVITY: 30, // m/s^2
            PLAYER: {
                SPEED_WALK: 10,
                SPEED_RUN: 22,
                JUMP_FORCE: 15,
                HEIGHT: 1.8,
                REACH: 6,
                MAX_HP: 100,
                MAX_STAMINA: 100,
                MAX_MANA: 100,
                STAMINA_REGEN: 15,
                MANA_REGEN: 5
            },
            DAY_LENGTH: 240, // Seconds for full 24h cycle
            COLORS: {
                SKY_DAY: 0x87CEEB,
                SKY_NIGHT: 0x050510,
                SUN_DAWN: 0xffaa00,
                SUN_NOON: 0xffffff,
                FOG: 0xcccccc
            }
        };

        // ==========================================
        // UTILITIES
        // ==========================================
        const rand = (min, max) => Math.random() * (max - min) + min;
        const randInt = (min, max) => Math.floor(rand(min, max));
        
        // Simple 1D Perlin-like noise for terrain height
        function noise(x, z) {
            return Math.sin(x * 0.01) * Math.cos(z * 0.01) * 5 + Math.sin(x * 0.03 + z * 0.03) * 2;
        }

        // ==========================================
        // GAME STATE & SYSTEMS
        // ==========================================
        
        class Game {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.clock = new THREE.Clock();
                
                // Systems
                this.timeSystem = null;
                this.weatherSystem = null;
                this.entityManager = null;
                this.particleSystem = null;
                this.world = null;

                // Player State
                this.player = {
                    hp: CONFIG.PLAYER.MAX_HP,
                    stamina: CONFIG.PLAYER.MAX_STAMINA,
                    mana: CONFIG.PLAYER.MAX_MANA,
                    inventory: { wood: 0, stone: 0 },
                    activeSlot: 1, // 1:Sword, 2:Magic, 3:Build Wood, 4:Build Stone
                    isBuilding: false,
                    velocity: new THREE.Vector3(),
                    onGround: false
                };

                this.input = { w:0, a:0, s:0, d:0, space:0, shift:0, click:0, rclick:0 };
                this.projectiles = [];
                this.raycaster = new THREE.Raycaster();
            }

            init() {
                // 1. Scene & Camera
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(CONFIG.COLORS.SKY_DAY);
                this.scene.fog = new THREE.Fog(CONFIG.COLORS.FOG, 10, 500);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 10, 0);

                // 2. Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);

                // 3. Inputs
                this.controls = new PointerLockControls(this.camera, document.body);
                this.setupInputs();

                // 4. Initialize Sub-Systems (ORDER MATTERS)
                this.timeSystem = new TimeSystem(this);
                this.weatherSystem = new WeatherSystem(this);
                this.world = new WorldBuilder(this); // Init World BEFORE Entity Manager
                this.entityManager = new EntityManager(this);
                this.particleSystem = new ParticleSystem(this);

                // 5. Weapon Model (Attached to Camera)
                this.createWeaponModel();

                // 6. Start Loop
                document.getElementById('loader').style.display = 'none';
                this.animate();
            }

            setupInputs() {
                const onKey = (code, down) => {
                    switch(code) {
                        case 'KeyW': this.input.w = down; break;
                        case 'KeyA': this.input.a = down; break;
                        case 'KeyS': this.input.s = down; break;
                        case 'KeyD': this.input.d = down; break;
                        case 'Space': this.input.space = down; break;
                        case 'ShiftLeft': this.input.shift = down; break;
                        case 'Digit1': if(down) this.setSlot(1); break;
                        case 'Digit2': if(down) this.setSlot(2); break;
                        case 'Digit3': if(down) this.setSlot(3); break;
                        case 'Digit4': if(down) this.setSlot(4); break;
                        case 'KeyB': if(down) this.toggleBuildMode(); break;
                    }
                };

                document.addEventListener('keydown', e => onKey(e.code, true));
                document.addEventListener('keyup', e => onKey(e.code, false));
                document.addEventListener('mousedown', e => {
                    if(!this.controls.isLocked) return;
                    if(e.button === 0) this.onLeftClick();
                    if(e.button === 2) this.onRightClick();
                });

                document.getElementById('start-btn').addEventListener('click', () => this.controls.lock());
                
                this.controls.addEventListener('lock', () => {
                    document.getElementById('blocker').style.display = 'none';
                });
                this.controls.addEventListener('unlock', () => {
                    if(this.player.hp > 0) document.getElementById('blocker').style.display = 'flex';
                });
            }

            setSlot(id) {
                this.player.activeSlot = id;
                document.querySelectorAll('.slot').forEach(el => el.classList.remove('active'));
                document.querySelector(`.slot[data-id="${id}"]`).classList.add('active');
                
                // Show/Hide Weapon
                this.weaponGroup.visible = (id === 1);
                this.wandGroup.visible = (id === 2);

                // Build mode auto-toggle
                if (id > 2 && !this.player.isBuilding) this.toggleBuildMode(true);
                if (id <= 2 && this.player.isBuilding) this.toggleBuildMode(false);
            }

            toggleBuildMode(forceState) {
                this.player.isBuilding = forceState !== undefined ? forceState : !this.player.isBuilding;
                const info = document.getElementById('build-preview-info');
                info.style.display = this.player.isBuilding ? 'block' : 'none';
                this.world.previewMesh.visible = this.player.isBuilding;
            }

            createWeaponModel() {
                // Sword
                this.weaponGroup = new THREE.Group();
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.8, 0.1), new THREE.MeshStandardMaterial({color:0xcccccc, metalness:0.8, roughness:0.2}));
                blade.position.y = 0.4;
                const guard = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.05, 0.12), new THREE.MeshStandardMaterial({color:0x444444}));
                guard.position.y = 0.0;
                const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.2), new THREE.MeshStandardMaterial({color:0x8B4513}));
                handle.position.y = -0.15;
                this.weaponGroup.add(blade, guard, handle);
                
                this.weaponGroup.position.set(0.5, -0.4, -0.8);
                this.weaponGroup.rotation.set(0.2, -0.2, 0);
                this.camera.add(this.weaponGroup);

                // Magic Wand
                this.wandGroup = new THREE.Group();
                const stick = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.01, 0.6), new THREE.MeshStandardMaterial({color:0x503010}));
                const gem = new THREE.Mesh(new THREE.DodecahedronGeometry(0.06), new THREE.MeshStandardMaterial({color:0x00ffff, emissive:0x0088ff, emissiveIntensity:1}));
                gem.position.y = 0.3;
                this.wandGroup.add(stick, gem);
                this.wandGroup.position.set(0.5, -0.4, -0.8);
                this.wandGroup.rotation.set(0.4, -0.2, 0);
                this.wandGroup.visible = false;
                this.camera.add(this.wandGroup);
            }

            onLeftClick() {
                if(this.player.isBuilding) {
                    this.world.tryPlaceBlock();
                } else if(this.player.activeSlot === 1) {
                    // Melee Attack
                    this.playWeaponAnim(this.weaponGroup);
                    this.entityManager.checkMeleeHit();
                } else if (this.player.activeSlot === 2) {
                    // Magic Blast (Small)
                    if(this.player.mana >= 5) {
                        this.player.mana -= 5;
                        this.spawnProjectile('magic_missile');
                        this.playWeaponAnim(this.wandGroup);
                    }
                }
            }

            onRightClick() {
                if(this.player.isBuilding) {
                    this.world.tryRemoveBlock();
                } else if (this.player.activeSlot === 2) {
                    // Fireball (Big)
                    if(this.player.mana >= 20) {
                        this.player.mana -= 20;
                        this.spawnProjectile('fireball');
                        this.playWeaponAnim(this.wandGroup);
                    }
                }
            }

            playWeaponAnim(group) {
                const startRot = group.rotation.clone();
                // Simple swing
                group.rotation.x += 0.5;
                group.rotation.y -= 0.5;
                setTimeout(() => {
                    group.rotation.copy(startRot);
                }, 150);
            }

            spawnProjectile(type) {
                const dir = new THREE.Vector3();
                this.camera.getWorldDirection(dir);
                const spawnPos = this.camera.position.clone().add(dir.multiplyScalar(1));
                
                const proj = {
                    type: type,
                    mesh: null,
                    velocity: dir.normalize().multiplyScalar(type === 'fireball' ? 25 : 40),
                    life: 3.0
                };

                let geo, mat;
                if(type === 'fireball') {
                    geo = new THREE.SphereGeometry(0.4);
                    mat = new THREE.MeshStandardMaterial({color:0xff4400, emissive:0xff2200, emissiveIntensity:2});
                } else {
                    geo = new THREE.IcosahedronGeometry(0.15);
                    mat = new THREE.MeshStandardMaterial({color:0x00ffff, emissive:0x00ffff, emissiveIntensity:2});
                }
                
                proj.mesh = new THREE.Mesh(geo, mat);
                proj.mesh.position.copy(spawnPos);
                
                // Add light to projectile
                const light = new THREE.PointLight(mat.color, 1, 10);
                proj.mesh.add(light);

                this.scene.add(proj.mesh);
                this.projectiles.push(proj);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const dt = Math.min(this.clock.getDelta(), 0.1);

                if(!this.controls.isLocked) return;

                // 1. Update Physics / Player
                this.updatePlayer(dt);

                // 2. Update Systems
                this.timeSystem.update(dt);
                this.weatherSystem.update(dt);
                this.entityManager.update(dt);
                this.particleSystem.update(dt);
                this.world.update(dt);

                // 3. Update Projectiles
                this.updateProjectiles(dt);

                // 4. Update HUD
                this.updateHUD();

                // 5. Render
                this.renderer.render(this.scene, this.camera);
            }

            updatePlayer(dt) {
                // Regen
                this.player.stamina = Math.min(this.player.stamina + CONFIG.PLAYER.STAMINA_REGEN * dt, CONFIG.PLAYER.MAX_STAMINA);
                this.player.mana = Math.min(this.player.mana + CONFIG.PLAYER.MANA_REGEN * dt, CONFIG.PLAYER.MAX_MANA);

                // Movement
                const speed = this.input.shift && this.player.stamina > 0 ? CONFIG.PLAYER.SPEED_RUN : CONFIG.PLAYER.SPEED_WALK;
                if(this.input.shift && (this.input.w || this.input.a || this.input.s || this.input.d)) {
                    this.player.stamina = Math.max(0, this.player.stamina - 15 * dt);
                }

                // Physics (Simplified Euler integration)
                this.player.velocity.y -= CONFIG.GRAVITY * dt;

                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                
                // Get directions flat on XZ plane
                this.camera.getWorldDirection(forward);
                forward.y = 0; forward.normalize();
                right.crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

                const moveDir = new THREE.Vector3();
                if(this.input.w) moveDir.add(forward);
                if(this.input.s) moveDir.sub(forward);
                if(this.input.d) moveDir.add(right);
                if(this.input.a) moveDir.sub(right);
                
                if(moveDir.length() > 0) moveDir.normalize().multiplyScalar(speed * dt);

                // Apply XZ Movement
                this.controls.moveRight( (Number(this.input.d) - Number(this.input.a)) * speed * dt );
                this.controls.moveForward( (Number(this.input.w) - Number(this.input.s)) * speed * dt );

                // Apply Y Movement
                this.camera.position.y += this.player.velocity.y * dt;

                // Ground Collision
                const groundH = this.world.getHeightAt(this.camera.position.x, this.camera.position.z);
                if(this.camera.position.y < groundH + CONFIG.PLAYER.HEIGHT) {
                    this.camera.position.y = groundH + CONFIG.PLAYER.HEIGHT;
                    this.player.velocity.y = 0;
                    this.player.onGround = true;
                } else {
                    this.player.onGround = false;
                }

                // Jump
                if(this.input.space && this.player.onGround) {
                    this.player.velocity.y = CONFIG.PLAYER.JUMP_FORCE;
                }
            }

            updateProjectiles(dt) {
                for(let i = this.projectiles.length - 1; i >= 0; i--) {
                    const p = this.projectiles[i];
                    p.life -= dt;
                    p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));

                    // Simple ground/object collision check
                    const groundH = this.world.getHeightAt(p.mesh.position.x, p.mesh.position.z);
                    let hit = false;

                    // Hit ground?
                    if(p.mesh.position.y <= groundH) hit = true;
                    // Hit Entity?
                    const hitEntity = this.entityManager.checkProjectileHit(p.mesh.position, 1.0);
                    if(hitEntity) {
                        hitEntity.takeDamage(p.type === 'fireball' ? 40 : 15);
                        hit = true;
                    }

                    if(hit || p.life <= 0) {
                        // Explode
                        this.particleSystem.emitExplosion(p.mesh.position, p.type === 'fireball' ? 0xff4400 : 0x00ffff);
                        this.scene.remove(p.mesh);
                        this.projectiles.splice(i, 1);
                    }
                }
            }

            updateHUD() {
                // Bars
                document.getElementById('bar-hp').style.width = (this.player.hp / CONFIG.PLAYER.MAX_HP * 100) + '%';
                document.getElementById('val-hp').innerText = Math.floor(this.player.hp);
                
                document.getElementById('bar-mp').style.width = (this.player.mana / CONFIG.PLAYER.MAX_MANA * 100) + '%';
                document.getElementById('val-mp').innerText = Math.floor(this.player.mana);

                document.getElementById('bar-st').style.width = (this.player.stamina / CONFIG.PLAYER.MAX_STAMINA * 100) + '%';
                document.getElementById('val-st').innerText = Math.floor(this.player.stamina);

                // Inventory Counts
                document.getElementById('count-wood').innerText = this.player.inventory.wood;
                document.getElementById('count-stone').innerText = this.player.inventory.stone;

                // Minimap Update (Draw player dot and nearby entities)
                this.drawMinimap();
            }

            drawMinimap() {
                const canvas = document.getElementById('minimap-canvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0,0,150,150);
                
                // Draw Entities relative to center
                const range = 100; // view range
                const px = this.camera.position.x;
                const pz = this.camera.position.z;

                this.entityManager.entities.forEach(e => {
                    const dx = e.mesh.position.x - px;
                    const dz = e.mesh.position.z - pz;
                    // Scale to canvas (150px)
                    // Map range (-100, 100) to (0, 150)
                    const mx = (dx / range) * 75 + 75;
                    const mz = (dz / range) * 75 + 75;

                    if(mx > 0 && mx < 150 && mz > 0 && mz < 150) {
                        ctx.fillStyle = e.type === 'ENEMY' ? 'red' : 'green';
                        if(e.type === 'RESOURCE') ctx.fillStyle = '#aaa';
                        ctx.beginPath();
                        ctx.arc(mx, mz, 3, 0, Math.PI*2);
                        ctx.fill();
                    }
                });
            }

            log(msg, type='normal') {
                const el = document.getElementById('message-log');
                const line = document.createElement('div');
                line.className = 'log-entry ' + (type === 'gain' ? 'log-gain' : type === 'warn' ? 'log-warn' : '');
                line.innerText = msg;
                el.prepend(line);
                if(el.children.length > 5) el.lastChild.remove();
            }
        }

        // ==========================================
        // SYSTEM: TIME & SKY
        // ==========================================
        class TimeSystem {
            constructor(game) {
                this.game = game;
                this.elapsed = CONFIG.DAY_LENGTH * 0.3; // Start morning
                this.dayCount = 1;
                
                // Sun
                this.sunLight = new THREE.DirectionalLight(CONFIG.COLORS.SUN_NOON, 1);
                this.sunLight.castShadow = true;
                this.sunLight.shadow.mapSize.width = 2048;
                this.sunLight.shadow.mapSize.height = 2048;
                this.sunLight.shadow.camera.near = 0.5;
                this.sunLight.shadow.camera.far = 500;
                this.sunLight.shadow.camera.left = -100;
                this.sunLight.shadow.camera.right = 100;
                this.sunLight.shadow.camera.top = 100;
                this.sunLight.shadow.camera.bottom = -100;
                this.game.scene.add(this.sunLight);

                // Sun Mesh
                this.sunMesh = new THREE.Mesh(new THREE.SphereGeometry(20), new THREE.MeshBasicMaterial({color: CONFIG.COLORS.SUN_NOON}));
                this.game.scene.add(this.sunMesh);

                // Stars
                const starsGeo = new THREE.BufferGeometry();
                const starPos = [];
                for(let i=0; i<1000; i++) {
                    const r = 400;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    starPos.push(r * Math.sin(phi) * Math.cos(theta));
                    starPos.push(r * Math.sin(phi) * Math.sin(theta));
                    starPos.push(r * Math.cos(phi));
                }
                starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
                this.stars = new THREE.Points(starsGeo, new THREE.PointsMaterial({color:0xffffff, size:2}));
                this.game.scene.add(this.stars);

                // Ambient
                this.ambient = new THREE.HemisphereLight(0x8888ff, 0x444444, 0.2);
                this.game.scene.add(this.ambient);
            }

            update(dt) {
                this.elapsed += dt;
                if(this.elapsed >= CONFIG.DAY_LENGTH) {
                    this.elapsed = 0;
                    this.dayCount++;
                }

                // 0 to 1 cycle
                const cycle = this.elapsed / CONFIG.DAY_LENGTH;
                
                // Sun Orbit (Rotates around Z axis)
                const angle = (cycle * Math.PI * 2) - (Math.PI / 2); // Start at bottom
                const r = 300;
                const sy = Math.sin(angle) * r;
                const sz = Math.cos(angle) * r;

                this.sunLight.position.set(0, sy, sz);
                this.sunMesh.position.copy(this.sunLight.position);
                
                // Shadow update target (follow player loosely)
                this.sunLight.target.position.set(this.game.camera.position.x, 0, this.game.camera.position.z);
                this.sunLight.target.updateMatrixWorld();

                // Sky Color & Light Intensity
                const isDay = sy > 0;
                const intensity = Math.max(0, Math.sin(angle));
                
                this.sunLight.intensity = intensity;
                this.ambient.intensity = 0.1 + (intensity * 0.5);
                this.stars.visible = !isDay;

                // Color Lerp
                if(isDay) {
                    this.game.scene.background.setHex(CONFIG.COLORS.SKY_DAY);
                    this.game.scene.fog.color.setHex(CONFIG.COLORS.FOG);
                } else {
                    this.game.scene.background.setHex(CONFIG.COLORS.SKY_NIGHT);
                    this.game.scene.fog.color.setHex(0x111111);
                }

                // UI
                const hours = Math.floor(cycle * 24);
                const mins = Math.floor((cycle * 24 * 60) % 60);
                document.getElementById('clock-time').innerText = `${hours.toString().padStart(2,'0')}:${mins.toString().padStart(2,'0')}`;
                document.getElementById('day-count').innerText = `Day ${this.dayCount}`;
            }
        }

        // ==========================================
        // SYSTEM: WORLD & BUILDING
        // ==========================================
        class WorldBuilder {
            constructor(game) {
                this.game = game;
                this.blocks = new Map(); // "x,y,z" -> mesh
                this.previewMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(1,1,1),
                    new THREE.MeshBasicMaterial({color: 0x00ff00, wireframe: true, transparent:true, opacity:0.5})
                );
                this.game.scene.add(this.previewMesh);
                this.previewMesh.visible = false;
                
                this.generateTerrain();
            }

            generateTerrain() {
                // Ground Plane with noise
                const geo = new THREE.PlaneGeometry(CONFIG.WORLD_SIZE, CONFIG.WORLD_SIZE, 128, 128);
                geo.rotateX(-Math.PI / 2);
                const pos = geo.attributes.position;
                for(let i=0; i<pos.count; i++) {
                    pos.setY(i, noise(pos.getX(i), pos.getZ(i)));
                }
                geo.computeVertexNormals();
                const mat = new THREE.MeshStandardMaterial({ color: 0x225522, roughness: 0.8 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.receiveShadow = true;
                this.game.scene.add(mesh);
            }

            getHeightAt(x, z) {
                // Return exact Y of noise function
                return noise(x, z);
            }

            update(dt) {
                if(this.game.player.isBuilding) {
                    this.updatePreview();
                }
            }

            updatePreview() {
                // Raycast from camera center
                this.game.raycaster.setFromCamera({x:0, y:0}, this.game.camera);
                const intersects = this.game.raycaster.intersectObjects(this.game.scene.children);
                
                // Find first valid hit (terrain or block)
                const hit = intersects.find(i => i.object !== this.previewMesh && !i.object.isEntity); // simplified check
                
                if(hit && hit.distance < 10) {
                    const p = hit.point.add(hit.face.normal.multiplyScalar(0.5));
                    // Snap to grid
                    this.previewMesh.position.set(
                        Math.floor(p.x) + 0.5,
                        Math.floor(p.y) + 0.5,
                        Math.floor(p.z) + 0.5
                    );
                    this.previewMesh.material.color.setHex(0x00ff00);
                } else {
                    this.previewMesh.material.color.setHex(0xff0000);
                }
            }

            tryPlaceBlock() {
                const pos = this.previewMesh.position;
                const key = `${pos.x},${pos.y},${pos.z}`;
                
                if(this.blocks.has(key)) return;

                // Check Cost
                const type = this.game.player.activeSlot === 3 ? 'wood' : 'stone';
                if(this.game.player.inventory[type] >= 1) {
                    this.game.player.inventory[type]--;
                    
                    const mat = new THREE.MeshStandardMaterial({
                        map: this.createTexture(type),
                        roughness: 0.9
                    });
                    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), mat);
                    mesh.position.copy(pos);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    
                    this.game.scene.add(mesh);
                    this.blocks.set(key, mesh);
                    this.game.log(`Placed ${type} block`);
                } else {
                    this.game.log(`Need ${type}!`, 'warn');
                }
            }

            tryRemoveBlock() {
                // Remove logic similar to placement but checking existing blocks
                // Simplified for this demo:
                this.game.raycaster.setFromCamera({x:0, y:0}, this.game.camera);
                const intersects = this.game.raycaster.intersectObjects(Array.from(this.blocks.values()));
                
                if(intersects.length > 0 && intersects[0].distance < 10) {
                    const obj = intersects[0].object;
                    this.game.scene.remove(obj);
                    
                    // Find key to remove from map
                    for(let [key, val] of this.blocks) {
                        if(val === obj) {
                            this.blocks.delete(key);
                            break;
                        }
                    }
                    this.game.log("Block removed");
                }
            }

            createTexture(type) {
                // Procedural texture generation for blocks
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = type === 'wood' ? '#8B4513' : '#777777';
                ctx.fillRect(0,0,64,64);
                
                // Add noise
                for(let i=0; i<100; i++) {
                    ctx.fillStyle = `rgba(0,0,0,${Math.random()*0.2})`;
                    ctx.fillRect(Math.random()*64, Math.random()*64, 4, 4);
                }
                
                // Board/Brick lines
                ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                ctx.lineWidth = 2;
                if(type === 'wood') {
                    ctx.beginPath(); ctx.moveTo(0,16); ctx.lineTo(64,16); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0,32); ctx.lineTo(64,32); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0,48); ctx.lineTo(64,48); ctx.stroke();
                } else {
                    ctx.strokeRect(0,0,32,32);
                    ctx.strokeRect(32,0,32,32);
                    ctx.strokeRect(0,32,32,32);
                    ctx.strokeRect(32,32,32,32);
                }

                const tex = new THREE.CanvasTexture(canvas);
                tex.magFilter = THREE.NearestFilter;
                return tex;
            }
        }

        // ==========================================
        // SYSTEM: ENTITIES & AI
        // ==========================================
        class EntityManager {
            constructor(game) {
                this.game = game;
                this.entities = [];
                this.populate();
            }

            populate() {
                // Trees
                for(let i=0; i<300; i++) this.spawnResource('tree');
                // Rocks
                for(let i=0; i<100; i++) this.spawnResource('rock');
                // Wolves
                for(let i=0; i<15; i++) this.spawnMob('wolf');
                // Cubes (Goal)
                for(let i=0; i<5; i++) this.spawnMob('cube');
            }

            spawnResource(type) {
                const pos = this.getRandomPos();
                const ent = new ResourceEntity(type, pos);
                this.add(ent);
            }

            spawnMob(type) {
                const pos = this.getRandomPos();
                const ent = new MobEntity(type, pos);
                this.add(ent);
            }

            add(ent) {
                this.entities.push(ent);
                this.game.scene.add(ent.mesh);
            }

            getRandomPos() {
                const angle = Math.random() * Math.PI * 2;
                const dist = rand(50, 800);
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;
                const y = this.game.world.getHeightAt(x, z);
                return new THREE.Vector3(x, y, z);
            }

            update(dt) {
                this.entities = this.entities.filter(e => {
                    if(e.dead) {
                        this.game.scene.remove(e.mesh);
                        return false;
                    }
                    e.update(dt, this.game.camera.position, this.game.world);
                    return true;
                });
            }

            checkMeleeHit() {
                const playerPos = this.game.camera.position;
                const dir = new THREE.Vector3();
                this.game.camera.getWorldDirection(dir);
                
                let hitSomething = false;

                this.entities.forEach(e => {
                    if(e.mesh.position.distanceTo(playerPos) < CONFIG.PLAYER.REACH) {
                        // Check angle
                        const toEnt = e.mesh.position.clone().sub(playerPos).normalize();
                        if(dir.dot(toEnt) > 0.5) { // 60 degree cone roughly
                            e.takeDamage(25);
                            this.game.particleSystem.emitHit(e.mesh.position);
                            hitSomething = true;
                        }
                    }
                });
                
                return hitSomething;
            }

            checkProjectileHit(pos, radius) {
                return this.entities.find(e => e.mesh.position.distanceTo(pos) < (e.radius + radius));
            }
        }

        class Entity {
            constructor(type, pos) {
                this.type = 'GENERIC'; // RESOURCE, ENEMY, PASSIVE
                this.subtype = type;
                this.mesh = new THREE.Group();
                this.mesh.position.copy(pos);
                this.mesh.isEntity = true; // Flag for raycaster
                this.hp = 100;
                this.dead = false;
                this.radius = 2;
            }
            update(dt, playerPos, world) {}
            takeDamage(amount) {}
        }

        class ResourceEntity extends Entity {
            constructor(type, pos) {
                super(type, pos);
                this.type = 'RESOURCE';
                this.hp = 50;
                
                if(type === 'tree') {
                    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1, 4), new THREE.MeshStandardMaterial({color: 0x553311}));
                    trunk.position.y = 2;
                    const leaves = new THREE.Mesh(new THREE.ConeGeometry(4, 8, 8), new THREE.MeshStandardMaterial({color: 0x228822}));
                    leaves.position.y = 7;
                    this.mesh.add(trunk, leaves);
                    this.radius = 1.5;
                } else if (type === 'rock') {
                    const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(1.5), new THREE.MeshStandardMaterial({color: 0x777777}));
                    rock.position.y = 1;
                    rock.scale.set(1.5, 1, 1.2);
                    this.mesh.add(rock);
                    this.radius = 2;
                }
            }
            
            takeDamage(amount) {
                this.hp -= amount;
                // Flash white
                this.mesh.children.forEach(c => {
                    c.material.emissive.setHex(0xffffff);
                    setTimeout(() => c.material.emissive.setHex(0x000000), 100);
                });

                if(this.hp <= 0) {
                    this.dead = true;
                    // Give loot
                    if(this.subtype === 'tree') {
                        gameInstance.player.inventory.wood += 5;
                        gameInstance.log("+5 Wood", 'gain');
                    } else {
                        gameInstance.player.inventory.stone += 3;
                        gameInstance.log("+3 Stone", 'gain');
                    }
                }
            }
        }

        class MobEntity extends Entity {
            constructor(type, pos) {
                super(type, pos);
                this.type = type === 'cube' ? 'PASSIVE' : 'ENEMY';
                this.state = 'IDLE'; // IDLE, CHASE, ATTACK
                this.attackTimer = 0;
                
                if(type === 'wolf') {
                    this.hp = 80;
                    const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 2), new THREE.MeshStandardMaterial({color: 0x333333}));
                    body.position.y = 1;
                    const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshStandardMaterial({color: 0x333333}));
                    head.position.set(0, 1.8, 1);
                    const eyes = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.2, 0.1), new THREE.MeshBasicMaterial({color: 0xff0000}));
                    eyes.position.set(0, 1.9, 1.4);
                    this.mesh.add(body, head, eyes);
                } else if(type === 'cube') {
                    this.hp = 10;
                    const geo = new THREE.BoxGeometry(2,2,2);
                    const mat = new THREE.MeshStandardMaterial({color: 0xffd700, emissive: 0xffa500});
                    this.mesh.add(new THREE.Mesh(geo, mat));
                    this.mesh.position.y = 4;
                }
            }

            update(dt, playerPos, world) {
                if(this.subtype === 'cube') {
                    this.mesh.rotation.y += dt;
                    return;
                }

                const dist = this.mesh.position.distanceTo(playerPos);
                
                // AI Logic
                if(dist < 30) {
                    this.state = 'CHASE';
                } else {
                    this.state = 'IDLE';
                }

                if(this.state === 'CHASE') {
                    // Look at player
                    this.mesh.lookAt(playerPos.x, this.mesh.position.y, playerPos.z);
                    
                    if(dist > 3) {
                        // Move towards
                        const dir = new THREE.Vector3().subVectors(playerPos, this.mesh.position).normalize();
                        this.mesh.position.add(dir.multiplyScalar(8 * dt)); // Speed 8
                        // Adjust Y to terrain
                        this.mesh.position.y = world.getHeightAt(this.mesh.position.x, this.mesh.position.z);
                    } else {
                        // Attack
                        if(this.attackTimer <= 0) {
                            this.attackTimer = 1.5;
                            gameInstance.player.hp -= 15;
                            gameInstance.particleSystem.emitBlood(gameInstance.camera.position);
                            gameInstance.log("Bitten by Wolf!", 'warn');
                            if(gameInstance.player.hp <= 0) {
                                document.getElementById('game-over').style.display = 'flex';
                                gameInstance.controls.unlock();
                            }
                        }
                    }
                }

                if(this.attackTimer > 0) this.attackTimer -= dt;
            }

            takeDamage(amount) {
                this.hp -= amount;
                // Knockback
                this.mesh.position.y += 0.5; 
                this.mesh.children.forEach(c => {
                    c.material.color.setHex(0xff0000);
                    setTimeout(() => c.material.color.setHex(this.subtype === 'wolf' ? 0x333333 : 0xffd700), 200);
                });

                if(this.hp <= 0) {
                    this.dead = true;
                    if(this.subtype === 'cube') {
                        // Win condition logic handled by score check in main loop usually, 
                        // but here we simplify:
                        gameInstance.log("Golden Cube Destroyed/Collected!", 'gain');
                    } else {
                        gameInstance.log("Wolf Slain");
                    }
                }
            }
        }

        // ==========================================
        // SYSTEM: PARTICLES & FX
        // ==========================================
        class ParticleSystem {
            constructor(game) {
                this.game = game;
                this.particles = [];
                
                // Pre-create geometry for performance
                this.boxGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            }

            emitHit(pos) {
                for(let i=0; i<5; i++) {
                    this.createParticle(pos, 0xffffff, 3);
                }
            }

            emitBlood(pos) {
                // Red particles near camera/player
                const p = pos.clone().add(new THREE.Vector3(0, -0.5, 0));
                for(let i=0; i<10; i++) {
                    this.createParticle(p, 0xff0000, 2);
                }
                
                // Screen effect
                const overlay = document.getElementById('damage-overlay');
                overlay.style.opacity = 0.8;
                setTimeout(() => overlay.style.opacity = 0, 300);
            }

            emitExplosion(pos, color) {
                for(let i=0; i<20; i++) {
                    this.createParticle(pos, color, 8);
                }
            }

            createParticle(pos, color, speed) {
                const mesh = new THREE.Mesh(this.boxGeo, new THREE.MeshBasicMaterial({color: color}));
                mesh.position.copy(pos);
                
                // Random velocity
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5),
                    (Math.random() - 0.5) + 0.5, // slightly up
                    (Math.random() - 0.5)
                ).normalize().multiplyScalar(rand(2, speed));

                this.game.scene.add(mesh);
                this.particles.push({ mesh, vel, life: 1.0 });
            }

            update(dt) {
                for(let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.life -= dt;
                    p.vel.y -= CONFIG.GRAVITY * dt * 0.5; // Gravity on particles
                    p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
                    p.mesh.rotation.x += dt * 5;

                    // Ground collision
                    const gh = this.game.world.getHeightAt(p.mesh.position.x, p.mesh.position.z);
                    if(p.mesh.position.y < gh) {
                        p.mesh.position.y = gh;
                        p.vel.multiplyScalar(0.5); // Friction
                    }

                    if(p.life <= 0) {
                        this.game.scene.remove(p.mesh);
                        this.particles.splice(i, 1);
                    } else {
                        p.mesh.scale.setScalar(p.life); // Shrink
                    }
                }
            }
        }

        // ==========================================
        // SYSTEM: WEATHER (Simplified)
        // ==========================================
        class WeatherSystem {
            constructor(game) {
                this.game = game;
                // Placeholder for rain logic
            }
            update(dt) {
                // Could implement rain particles here using ParticleSystem
            }
        }

        // ==========================================
        // MAIN ENTRY
        // ==========================================
        const gameInstance = new Game();
        gameInstance.init();

        // Expose for debugging
        window.game = gameInstance;
    </script>
</body>
</html>